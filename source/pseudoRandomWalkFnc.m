function [ individual, indivParams ] = pseudoRandomWalkFnc(...
                                        gridMask, sourceIndex,...
                                        destinIndex, plot )

% pseudoRandomWalkFnc.m Generates pathway index values for one or more  
% pseudo random walks between a given source and destination on a 2D grid. 
% In this version the covariance matrix [sigma] is determined upon the
% distance from the nearest point on the basis solution (the euclidean 
% shortest path) at each iteration. 
%
% DESCRIPTION:
%
%   Function to iteratively compute a random walking path on a grid from a
%   source target gridcell to a source destination gridcell. Paths are
%   recorded as a sequence of grid cell index values.
% 
%   Warning: minimal error checking is performed.
%
% SYNTAX:
%
%   [ individual, indivParams ] =  pseudoRandomWalkFnc( gridMask,...
%                                   sourceIndex, destinIndex, plot )
%
% INPUTS:
%
%   gridMask =      [n x m] binary array with valid pathway grid cells 
%                   labeled as ones and invalid pathway grid cells labeled 
%                   as NaN placeholders
%
%   genomeLength =  [s] scalar with the maximum number of genomeLength that 
%                   the random walk function will undergo before automatic 
%                   termination
%
%   sourceIndex =   [i j] index value of the source node for the
%                   start of the pseudo random walk
%
%   destinIndex =   [p q] index value of the destination node for
%                   the termination of the pseudo random walk
%
%   plot =          [0|1] binary variable indicating whether or not a
%                   output plot illustrating the location of the computed
%                   pathway is desired (0 = False, 1 = True)
%
% OUTPUTS:
%
%   individual =    [v x j] array with the index values of the pathway
%                   from the source to the desintation node computed from
%                   the random walk process. Each row (v) is a viable
%                   pathway of length (j) generated by the function [v <= r
%                   & j <= s] 
%
%   indivParams =   [u] scalar optional plot handle output for pathway 
%                   image plot
%
% EXAMPLES:
%   
%   Example 1 =
%
%                   gridMask = zeros(100); 
%                   gridMask(1,:) = nan; 
%                   gridMask(:,1) = nan; 
%                   gridMask(end,:) = nan; 
%                   gridMask(:,end) = nan;
%                   sourceIndex = [20 20];
%                   destinIndex = [80 80];
%                   plot = 1;
%
%                   [individual, indivParams] = pseudoRandomWalkFnc(...
%                                               gridMask,sourceIndex,...
%                                               destinIndex,plot);
%
% CREDITS:
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%                                                                      %%
%%%                          Eric Daniel Fournier                        %%
%%%                  Bren School of Environmental Science                %%
%%%               University of California Santa Barbara                 %%
%%%                            September 2013                            %%
%%%                                                                      %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% Parse Inputs

p = inputParser;

addRequired(p,'nargin',@(x) x == 4);
addRequired(p,'nargout',@(x) x >= 1);
addRequired(p,'gridMask',@(x) isnumeric(x) && ismatrix(x) && ~isempty(x));
addRequired(p,'sourceIndex',@(x) isnumeric(x) && isrow(x) && ~isempty(x));
addRequired(p,'destinIndex',@(x) isnumeric(x) && isrow(x) && ~isempty(x));
addRequired(p,'plot',@(x) isnumeric(x) && isscalar(x) && ~isempty(x));

parse(p,nargin,nargout,gridMask,sourceIndex,destinIndex,plot);

%% Error Checking

if destinIndex == sourceIndex
    
    tit='Source Cannot be the Same as Destination';
    disp(tit);
    error('Source Cannot be the Same as Destination');
    
end

%% Iteration Parameters

gridMask(gridMask == 0) = NaN; % Temporary Fix...need to modify code to 
                               % accept pure binary gridMasks
gS = size(gridMask);
sF = nthroot((gS(1,1)*gS(1,2)),10);      % This controls the randomness          
sI = sourceIndex;
dI = destinIndex;
sD = pdist([sourceIndex; destinIndex]);
gL = ceil(5*sD);                      
individual = zeros(1,gL);
destinInd = sub2ind(gS,destinIndex(1,1),destinIndex(1,2));

%% Compute Basis and Basis Distances

basisInd = euclShortestWalkFnc(gridMask,sourceIndex,destinIndex);
basisInd = basisInd(any(basisInd,1))';
bS = size(basisInd,2);
bw = gridMask;
bw(basisInd) = 1;
basisDist = bwdist(bw);

%% Generate Pathways

iter = 0;
walkCheck = 0;
neighborhoodBoundaryError = 0;
gridMaskBoundaryError = 0;
culDeSacError = 0;
noValidNeighborError = 0;
success = 0;
failure = 0;

while walkCheck == 0
    
    iter = iter+1;
    visitedGrid = zeros(gS);
    visitedGrid(sI(1,1),sI(1,2)) = 1;
    visitedList = zeros(gL,2);
    visitedList(1,1) = sourceIndex(1,1);
    visitedList(1,2) = sourceIndex(1,2);
    
    for i = 1:gL+1
        
        % Initialize Parameters
        
        mu = -sign(visitedList(i,:)-dI);
        current = visitedList(i,:);
        neighborhoodSub = zeros(9,2);
        minBasisDist = basisDist(current(1,1),current(1,2));
        
        if minBasisDist == 0
            
            cov = sF*sqrt(1/(1/sF));
            
        else
            
            cov = sF*sqrt(1/minBasisDist);
            
        end
        
        sigma = [cov 0; 0 cov];
        
        % Construct Current Neighborhood
        
        j = current(1,1);
        k = current(1,2);
        neighborhoodSub(1,:) = [j-1,k-1];
        neighborhoodSub(2,:) = [j-1,k];
        neighborhoodSub(3,:) = [j-1,k+1];
        neighborhoodSub(4,:) = [j,k-1];
        neighborhoodSub(5,:) = [j,k];
        neighborhoodSub(6,:) = [j,k+1];
        neighborhoodSub(7,:) = [j+1,k-1];
        neighborhoodSub(8,:) = [j+1,k];
        neighborhoodSub(9,:) = [j+1,k+1];
        
        % Check Validity of Current Neighborhood
        
        if all(neighborhoodSub(:,1)) == 0 || all(neighborhoodSub(:,2)) == 0

            neighborhoodBoundaryError = neighborhoodBoundaryError + 1;
            walkCheck = 0;
            
            break
            
        else
            
        end
            
        neighborhoodInd = sub2ind(gS,neighborhoodSub(:,1),...
            neighborhoodSub(:,2));
        
        % Check Current Neighborhood Against the Grid Mask
        
        rawNeighbors = gridMask(neighborhoodInd);
        openNeighborCheck = ~isnan(rawNeighbors);
        openNeighbors = neighborhoodInd(openNeighborCheck);
        
        if sum(openNeighborCheck) == 0
            
            gridMaskBoundaryError = gridMaskBoundaryError + 1;
            walkCheck = 0;
            
            break
            
        else
            
        end
        
        % Check Current Neighborhood for Previously Visited Neighbors
        
        visitedCur = logical(visitedGrid(neighborhoodInd));
        visitedInd = neighborhoodInd(visitedCur);        
        [visitedNeighbors, ~] = intersect(...
            neighborhoodInd,visitedInd);
        newNeighbors = setdiff(neighborhoodInd,visitedNeighbors);
        numNewNeighbors = size(newNeighbors,1);
        
        if numNewNeighbors == 0
            
            culDeSacError = culDeSacError + 1;
            walkCheck = 0;
            
            break
            
        else
            
        end
        
        % Find Valid New Neighbors
        
        validNewNeighborsInd = intersect(openNeighbors,newNeighbors);
        
        if isempty(validNewNeighborsInd) == 1
            
            noValidNeighborError = noValidNeighborError + 1;
            walkCheck = 0;
            
            break
            
        else
            
        end
        
        % Initiate New Move Search
        
        validCheck = 0;
        
        while validCheck == 0
            
            newDirection = sign(round(mvnrnd(mu,sigma,1)));
            newSub = current + newDirection;
            newInd = sub2ind(gS,newSub(1,1),newSub(1,2));
            validCheck = ~isempty(intersect(newInd,validNewNeighborsInd));
            
        end
        
        % Evaluate Stopping Conditions
        
        if newInd == destinInd
            
            visitedList(i+1,:) = newSub;
            visitedGrid(newInd) = 1;
            success = success + 1;
            walkCheck = 1;
            
            break
            
        elseif i < gL && newInd ~= destinInd
            
            visitedList(i+1,:) = newSub;
            visitedGrid(newInd) = 1;
            walkCheck = 0;
            
        elseif i == gL && newInd ~= destinInd
            
            visitedList(i+1,:) = newSub;
            visitedGrid(newInd) = 1;
            walkCheck = 0;
            
            break
            
        end
        
    end
    
    if iter == 200 % DETERMINISTIC STOPPING CONDITION
        
        failure = failure + 1;
        walkCheck = 1;
        
    else
        
    end
    
end

anyVisited = visitedList(any(visitedList,2),:);
sizeAnyVisited = size(anyVisited,1);
individual(1,1:sizeAnyVisited) = sub2ind(gS,anyVisited(:,1),...
    anyVisited(:,2))'; 
        
%% Generate Output Plot as Specified by User

scrn = get(0,'screensize');

switch plot
    
    case 0
        
    case 1
        
        plotHandle = figure();
        u = size(individual);
        set(plotHandle,'position',scrn);
        
        for r = 1:u(1,1)
            
            tmp4 = individual(r,any(individual(r,:),1));
            subplot(ceil(sqrt(u(1,1))),ceil(sqrt(u(1,1))),r);
            tmp5 = gridMask;
            tmp5(isnan(tmp5)) = 5;
            tmp5(tmp4') = 1;
            tmp5(sI(1,1),sI(1,2)) = 2;
            tmp5(dI(1,1),dI(1,2)) = 3;
            colormap('jet');
            imagesc(tmp5);
            axis square;
            title(['Pathway #',num2str(r)],'FontSize',16,'FontWeight',...
                'Bold');
            set(gca,'XTick',[],'YTick',[]);
                
        end
    
end

%% Write Output Individual Parameters Object

indivParams = struct('genomeLength',gL,'iterations',iter,'basisLength',...
    bS,'neighborhoodBoundaryErrors',neighborhoodBoundaryError,...
    'gridMaskBoundaryErrors',gridMaskBoundaryError,'culDeSacErrors',...
    culDeSacError,'noValidNeighborErrors',noValidNeighborError,...
    'successes',success,'failures',failure);

end