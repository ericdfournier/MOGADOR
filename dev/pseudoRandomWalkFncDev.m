function [ individual ] = pseudoRandomWalkFncDev(   gridMask,...
                                                    sourceSub,...
                                                    destinSub )

% pseudoRandomWalkFnc.m Generates pathway index values for one or more  
% pseudo random walks between a given source and destination on a 2D grid. 
% In this version the covariance matrix [sigma] is determined upon the
% distance from the nearest point on the basis solution (the euclidean 
% shortest path) at each iteration. 
%
% DESCRIPTION:
%
%   Function to iteratively compute a random walking path on a grid from a
%   source target gridcell to a source destination gridcell. Paths are
%   recorded as a sequence of grid cell index values.
% 
%   Warning: minimal error checking is performed.
%
% SYNTAX:
%
%   [ individual, indivParams ] =  pseudoRandomWalkFnc( gridMask,...
%                                   sourceSub, destinSub, plot )
%
% INPUTS:
%
%   gridMask =      [n x m] binary array with valid pathway grid cells 
%                   labeled as ones and invalid pathway grid cells labeled 
%                   as zero placeholders
%
%   sourceSub =   [i j] index value of the source node for the
%                   start of the pseudo random walk
%
%   destinSub =   [p q] index value of the destination node for
%                   the termination of the pseudo random walk
%
%   plot =          [0|1] binary variable indicating whether or not a
%                   output plot illustrating the location of the computed
%                   pathway is desired (0 = False, 1 = True)
%
% OUTPUTS:
%
%   individual =    [v x j] array with the index values of the pathway
%                   from the source to the desintation node computed from
%                   the random walk process. Each row (v) is a viable
%                   pathway of length (j) generated by the function [v <= r
%                   & j <= s] 
%
%   indivParams =   [u] scalar optional plot handle output for pathway 
%                   image plot
%
% EXAMPLES:
%   
%   Example 1 =
%
%                   gridMask = zeros(100); 
%                   gridMask(1,:) = nan; 
%                   gridMask(:,1) = nan; 
%                   gridMask(end,:) = nan; 
%                   gridMask(:,end) = nan;
%                   sourceSub = [20 20];
%                   destinSub = [80 80];
%                   plot = 1;
%
%                   [individual, indivParams] = pseudoRandomWalkFnc(...
%                                               gridMask,sourceSub,...
%                                               destinSub,plot);
%
% CREDITS:
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%                                                                      %%
%%%                          Eric Daniel Fournier                        %%
%%%                  Bren School of Environmental Science                %%
%%%                 University of California Santa Barbara               %%
%%%                                                                      %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% Parse Inputs

P = inputParser;

addRequired(P,'nargin',@(x)...
    x == 3);
addRequired(P,'nargout',@(x)...
    x == 1);
addRequired(P,'gridMask',@(x)...
    isnumeric(x) &&...
    ismatrix(x) &&...
    ~isempty(x));
addRequired(P,'sourceSub',@(x)...
    isnumeric(x) &&...
    isrow(x) &&...
    ~isempty(x));
addRequired(P,'destinSub',@(x)...
    isnumeric(x) &&...
    isrow(x) &&...
    ~isempty(x));

parse(P,nargin,nargout,gridMask,sourceSub,destinSub);

%% Error Checking

if destinSub == sourceSub
    
    tit='Source Cannot be the Same as Destination';
    disp(tit);
    error('Source Cannot be the Same as Destination');
    
end

%% Function Parameters

sourceDistBasis = euclShortestWalkFnc(sourceSub,destinSub,gridMask);
sB = size(sourceDistBasis,2);
gL = 5.*sB;
individual = zeros(1,gL);

%% Initiate While Loop

currentInd = sub2ind(gS,sourceSub(1,1),sourceSub(1,2));
destinInd = sub2ind(gS,destinSub(1,1),destinSub(1,2));

while currentInd ~= destinInd;
    
    currentBasis = sourceDistBasis;
    isConcave = any(gridMask(currentBasis) == 0);
    
    if isConcave == 1
        
        [R, C] = ind2sub(gS,currentBasis(find(...
            gridMask(currentBasis) == 0,1,'first')));
        obstacleSub = [R C];
        diffVector = currentSub - obstacleSub;
        [theta, rho] = cart2pol(diffVector(1,1),diffVector(1,2));
        theta = (pi/2) + theta;
        mu = -sign(sourceSub - obstacleSub);
        R = [cos(theta) -sin(theta); sin(theta) cos(theta)];
        S = [log(rho) 0; 0 log(rho)];
        sigma = R.*S.*R';
        tryMove = sign(mvnrnd(mu,sigma));
                    
    elseif isConcave == 0
        
        [R, C] = ind2sub(gS,currentBasis(find(...
            gridMask(currentBasis) == 0,1,'first')));
        obstacleSub = [R C];
        diffVector = currentSub - obstacleSub;
        [theta, rho] = cart2pol(diffVector(1,1),diffVector(1,2));
        theta = (pi/2) + theta;
        mu = -sign(sourceSub - obstacleSub);
        R = [cos(theta) -sin(theta); sin(theta) cos(theta)];
        S = [log(rho) 0; 0 log(rho)];
        sigma = R.*S.*R';
        tryMove = sign(mvnrnd(mu,sigma));
        
    end
    

end